#!/usr/bin/env python3
"""
Generate C++ source file containing embedded binary assets.
Compresses binaries with zlib for efficient storage.
"""

import sys
import zlib
from pathlib import Path

def to_c_identifier(name: str) -> str:
    """Convert filename to valid C identifier."""
    result = name.replace('.', '_').replace('-', '_')
    if result[0].isdigit():
        result = '_' + result
    return result

def generate_asset_array(filepath: Path) -> tuple[str, str, int, int]:
    """Generate C array for a single file."""
    name = to_c_identifier(filepath.name)
    
    with open(filepath, 'rb') as f:
        data = f.read()
    
    original_size = len(data)
    compressed_data = zlib.compress(data, level=9)
    compressed_size = len(compressed_data)
    
    # Generate hex array
    hex_data = ', '.join(f'0x{b:02x}' for b in compressed_data)
    
    return name, hex_data, compressed_size, original_size

def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <assets_dir> <output.cpp>")
        sys.exit(1)
    
    assets_dir = Path(sys.argv[1])
    output_file = Path(sys.argv[2])
    
    # Collect all files in assets directory
    assets = []
    if assets_dir.exists():
        for f in sorted(assets_dir.iterdir()):
            if f.is_file() and not f.name.startswith('.'):
                assets.append(f)
    
    # Generate C++ source
    output = '''// Auto-generated file - DO NOT EDIT
// Generated by embed_assets.py

#include "core/assets.hpp"
#include "utils.hpp"
#include <array>
#include <cstring>
#include <map>
#include <sys/stat.h>
#include <cerrno>
#include <unistd.h>
#include <vector>
#include <zlib.h>
#include <fstream>

namespace hymo {

'''
    
    # Generate arrays for each asset
    asset_infos = []
    for filepath in assets:
        name, hex_data, size, original_size = generate_asset_array(filepath)
        output += f'// Asset: {filepath.name}\n'
        output += f'static const unsigned char asset_{name}[] = {{\n'
        
        # Split into lines of 16 bytes
        bytes_list = hex_data.split(', ')
        for i in range(0, len(bytes_list), 16):
            output += '    ' + ', '.join(bytes_list[i:i+16]) + ',\n'
        
        output += f'}};\n'
        output += f'static const size_t asset_{name}_size = {size};\n'
        output += f'static const size_t asset_{name}_original_size = {original_size};\n\n'
        
        asset_infos.append((filepath.name, name, size, original_size))
    
    # Generate asset registry (std::array for clang-tidy)
    n_entries = len(asset_infos) + 1  # +1 for sentinel
    output += '''
struct AssetEntry {
    const char* name;
    const unsigned char* data;
    size_t size;
    size_t original_size;
};

static const std::array<AssetEntry, ''' + str(n_entries) + '''> asset_registry = {{
'''
    
    for filename, name, size, original_size in asset_infos:
        output += f'    {{"{filename}", asset_{name}, asset_{name}_size, asset_{name}_original_size}},\n'

    
    output += '''    {nullptr, nullptr, 0, 0}  // sentinel
}};

const std::vector<std::string>& list_assets() {
    static std::vector<std::string> names;
    static bool initialized = false;
    if (!initialized) {
        for (const auto& entry : asset_registry) {
            if (entry.name == nullptr) break;
            names.push_back(entry.name);
        }
        initialized = true;
    }
    return names;
}

bool get_asset(const std::string& name, const uint8_t*& data, size_t& size) {
    for (const auto& entry : asset_registry) {
        if (entry.name == nullptr) break;
        if (name == entry.name) {
            data = entry.data;
            size = entry.size;
            return true;
        }
    }
    return false;
}

bool copy_asset_to_file(const std::string& name, const std::string& dest_path) {
    const AssetEntry* entry = nullptr;
    for (const auto& e : asset_registry) {
        if (e.name == nullptr) break;
        if (name == e.name) {
            entry = &e;
            break;
        }
    }
    
    if (!entry) {
        LOG_ERROR("Asset not found: " + name);
        return false;
    }
    
    // Remove existing file first
    unlink(dest_path.c_str());
    
    // Decompress
    std::vector<uint8_t> buffer(entry->original_size);
    uLongf destLen = entry->original_size;
    const int ret = uncompress(buffer.data(), &destLen, entry->data, entry->size);
    if (ret != Z_OK) {
        LOG_ERROR("Decompression failed for " + name + ": " + std::to_string(ret));
        return false;
    }
    
    std::ofstream ofs(dest_path, std::ios::binary);
    if (!ofs) {
        LOG_ERROR("Failed to open file for writing: " + dest_path + " (errno=" + std::to_string(errno) + ": " + strerror(errno) + ")");
        return false;
    }
    ofs.write(reinterpret_cast<const char*>(buffer.data()), destLen);
    if (!ofs.good()) {
        LOG_ERROR("Failed to write asset " + name + " to " + dest_path);
        return false;
    }
    return true;
}

} // namespace hymo
'''
    
    # Write output
    output_file.parent.mkdir(parents=True, exist_ok=True)
    with open(output_file, 'w') as f:
        f.write(output)
    
    print(f"Generated {output_file} with {len(assets)} assets")
    for filename, name, size, original_size in asset_infos:
        print(f"  - {filename}: {size} bytes (original: {original_size})")

if __name__ == '__main__':
    main()
